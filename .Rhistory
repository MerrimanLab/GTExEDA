fluidRow(
column(4,
wellPanel(
actionButton("btnBeep", "beep"),
actionButton("btnLevel", "level"),
actionButton("btnEnd", "end")
)),
column(4,
verbatimTextOutput("txtLevel"),
verbatimTextOutput("txtBeep"))
)
)
server <- function(input, output) {
beep <- eventReactive(input$btnBeep, {
results <- rbind(results, data.frame(level = currentLevel,
beep = currentBeep,
time = Sys.time()))
currentBeep <<- currentBeep + 1
return (currentBeep)
})
level <- eventReactive(input$btnLevel, {
currentBeep <<- 1
currentLevel <<- currentLevel + 1
return (currentLevel)
})
observe({
input$buttonEnd
isolate({write.csv(results, "beepResults.csv")})
})
output$txtBeep <- renderText({
beep()
})
output$txtLevel <- renderText({
level()
})
}
shinyApp(ui, server)
# Beep test timings
library(shiny)
currentLevel <- 1
currentBeep <- 1
results <- data.frame(level = c(0), beep = c(0), time = Sys.time())
ui <- fluidPage(
fluidRow(
column(4,
wellPanel(
actionButton("btnBeep", "beep"),
actionButton("btnLevel", "level"),
actionButton("btnEnd", "end")
)),
column(4,
verbatimTextOutput("txtLevel"),
verbatimTextOutput("txtBeep"))
)
)
server <- function(input, output) {
beep <- eventReactive(input$btnBeep, {
results <- rbind(results, data.frame(level = currentLevel,
beep = currentBeep,
time = Sys.time()))
currentBeep <<- currentBeep + 1
return (currentBeep)
})
level <- eventReactive(input$btnLevel, {
currentBeep <<- 1
currentLevel <<- currentLevel + 1
return (currentLevel)
})
observe({
input$buttonEnd
write.csv(results, "beepResults.csv")
})
output$txtBeep <- renderText({
beep()
})
output$txtLevel <- renderText({
level()
})
}
shinyApp(ui, server)
# Beep test timings
library(shiny)
currentLevel <- 1
currentBeep <- 1
results <- data.frame(level = c(0), beep = c(0), time = Sys.time())
ui <- fluidPage(
fluidRow(
column(4,
wellPanel(
actionButton("btnBeep", "beep"),
actionButton("btnLevel", "level"),
actionButton("btnEnd", "end")
)),
column(4,
verbatimTextOutput("txtLevel"),
verbatimTextOutput("txtBeep"),
verbatimTextOutput("txtEnd"))
)
)
server <- function(input, output) {
beep <- eventReactive(input$btnBeep, {
results <- rbind(results, data.frame(level = currentLevel,
beep = currentBeep,
time = Sys.time()))
currentBeep <<- currentBeep + 1
return (currentBeep)
})
level <- eventReactive(input$btnLevel, {
currentBeep <<- 1
currentLevel <<- currentLevel + 1
return (currentLevel)
})
observe({
input$btnEnd
write.csv(results, "beepResults.csv")
})
output$txtBeep <- renderText({
beep()
})
output$txtLevel <- renderText({
level()
})
}
shinyApp(ui, server)
getwd()
# Beep test timings
library(shiny)
currentLevel <- 1
currentBeep <- 1
results <- data.frame(level = c(0), beep = c(0), time = Sys.time())
ui <- fluidPage(
fluidRow(
column(4,
wellPanel(
actionButton("btnBeep", "beep"),
actionButton("btnLevel", "level"),
actionButton("btnEnd", "end")
)),
column(4,
verbatimTextOutput("txtLevel"),
verbatimTextOutput("txtBeep"),
verbatimTextOutput("txtEnd"))
)
)
server <- function(input, output) {
beep <- eventReactive(input$btnBeep, {
results <- rbind(results, data.frame(level = currentLevel,
beep = currentBeep,
time = Sys.time()))
currentBeep <<- currentBeep + 1
return (currentBeep)
})
level <- eventReactive(input$btnLevel, {
currentBeep <<- 1
currentLevel <<- currentLevel + 1
return (currentLevel)
})
endTest <- eventReactive(input$btnEnd, {
write.csv(results, "beepResults.csv")
})
output$txtBeep <- renderText({
beep()
})
output$txtLevel <- renderText({
level()
})
output$txtEnd <- renderText({
endTest()
"Test Finished"
})
}
shinyApp(ui, server)
# Beep test timings
library(shiny)
currentLevel <- 1
currentBeep <- 1
results <- data.frame(level = c(0), beep = c(0), time = Sys.time())
ui <- fluidPage(
fluidRow(
column(4,
wellPanel(
actionButton("btnBeep", "beep"),
actionButton("btnLevel", "level"),
actionButton("btnEnd", "end")
)),
column(4,
verbatimTextOutput("txtLevel"),
verbatimTextOutput("txtBeep"),
verbatimTextOutput("txtEnd"))
)
)
server <- function(input, output) {
beep <- eventReactive(input$btnBeep, {
results <<- rbind(results, data.frame(level = currentLevel,
beep = currentBeep,
time = Sys.time()))
currentBeep <<- currentBeep + 1
return (currentBeep)
})
level <- eventReactive(input$btnLevel, {
currentBeep <<- 1
currentLevel <<- currentLevel + 1
return (currentLevel)
})
endTest <- eventReactive(input$btnEnd, {
write.csv(results, "beepResults.csv")
})
output$txtBeep <- renderText({
beep()
})
output$txtLevel <- renderText({
level()
})
output$txtEnd <- renderText({
endTest()
"Test Finished"
})
}
shinyApp(ui, server)
shinyApp(ui, server)
shinyApp(ui, server)
# Beep test timings
library(shiny)
currentLevel <- 1
currentBeep <- 1
results <- data.frame(level = c(0), beep = c(0), time = Sys.time())
ui <- fluidPage(
fluidRow(
column(4,
wellPanel(
actionButton("btnBeep", "beep"),
actionButton("btnLevel", "level"),
actionButton("btnEnd", "end")
)),
column(4,
verbatimTextOutput("txtLevel"),
verbatimTextOutput("txtBeep"),
verbatimTextOutput("txtEnd"))
)
)
server <- function(input, output) {
beep <- eventReactive(input$btnBeep, {
results <<- rbind(results, data.frame(level = currentLevel,
beep = currentBeep,
time = Sys.time()))
currentBeep <<- currentBeep + 1
return (currentBeep)
})
level <- eventReactive(input$btnLevel, {
currentBeep <<- 1
currentLevel <<- currentLevel + 1
return (currentLevel)
})
endTest <- eventReactive(input$btnEnd, {
write.csv(results, "beepResults.csv")
})
output$txtBeep <- renderText({
beep()
})
output$txtLevel <- renderText({
level()
})
output$txtEnd <- renderText({
endTest()
"Test Finished"
})
}
shinyApp(ui, server)
results <- read.csv("beepResults.csv")
head(results)
lag(results$time)
results$time[2] - results$time[1]
results$time <- datetime(results$time)
results$time <- time(results$time)
head(results)
results <- read.csv("beepResults.csv")
results$time <- date(results$time)
results$time <- as.date(results$time)
?as.Date
results$time <- as.Date(results$time)
head(results)
as.difftime(results$time)
results <- read.csv("beepResults.csv")
head(as.difftime(results$time))
head(as.difftime(as.character(results$time)))
head(results)
head(as.Date(results$time, "UTC")
)
head(as.Date(results$time, tz="UTC")
)
head(as.Date(results$time, tz="POSIXlt"))
head(as.POIIXct(results$time))
head(as.POSIXct(results$time))
lag(head(as.POSIXct(results$time)))
xs<-head(as.POSIXct(results$time))
xs[1]
xs[2] - xs[1]
dif(xs)
diff(xs)
results <- read.csv("beepResults.csv")
results$time <- as.POSIXct(results$time)
results$delta <- diff(results$time)
results$delta <- c(NA, diff(results$time))
head(results)
tail(results)
?summarise
library(dplyr)
?summarise
summarise(group_by(results, level), nBeeps = n(), timePerBeep = mean(delta))
by_level <- summarise(group_by(results, level), nBeeps = n(), timePerBeep = mean(delta))
by_level
tail(by_level)
head(by_level, 20)
shiny::runApp('C:/Users/NickBurns/gitRepositories/myGits/LDCalculator/LDExplorer')
library(biomaRt)
library(bioMart)
library(biomart)
library(data.table)
data("iris3")
head(iris3)
irisDF <- iris
irisDT <- as.data.table(iris)
head(irisDF)
head(irisDT)
tail(irisDF)
tail(irisDT)
irisDF[1:10, ]
irisDT[1:10, ]
irisDT[1:10]
irisDF[1:3, 4:5]
irisDT[1:3, 4:5]
irisDT[1:3, .(4,5)]
irisDF[1:3, 4:5]
irisDF[1:3, c("Petal.Width", "Species")]
irisDT[1:3, .("Petal.Width", "Species")]
irisDT[, .("Petal.Width", "Species")]
irisDT[1:3, .(Petal.Width, Species)]
irisDT[seq(1, 150, by=30), .(Petal.Width, Species)]
irisDT[, .(Petal.Length, Petal.Width, Species), by = Species]
irisDT[, .(.N-1, Petal.Length, Petal.Width, Species), by = Species]
irisDT[1, .(Petal.Length, Petal.Width, Species), by = Species]
keys(irisDT)
irisDT.keys()
irisDT.keys
irisDT
setkey(irisDT, Species)
irisDT[Species, mult = "first"]
irisDT[.("setosa", "virginica", "veronica"), mult = "first"]
irisDT[c("setosa", "virginica", "veronica"), mult = "first"]
unique(iris$Species)
irisDT[c("setosa", "virginica", "versicolor"), mult = "first"]
irisDT[, mult = "first"]
irisDT[, mult = "first"]
irisDT[, mult = "first", by=Species]
for (species in unique(iris$Species)) {
irisDF[irisDF$Species == species, ][1, ]
}
for (species in unique(iris$Species)) {
print(irisDF[irisDF$Species == species, ][1, ])
}
sapply(unique(iris$Species), function (species) head(irisDF[irisDF$Species == species, ], 1))
t(sapply(unique(iris$Species), function (species) head(irisDF[irisDF$Species == species, ], 1)))
irisDT[, , by=Species][.N1]
irisDT[, , by=Species][,.N1]
irisDT[, , by=Species][,.N=1]
irisDT[, , by=Species][.N=1]
irisDT[.N=1, , by=Species]
irisDT[, .N=1, by=Species]
irisDT[, .1, by=Species]
irisDT[.1, , by=Species]
irisDT[,,by=Species]
irisDT[,,by=Species][.1]
irisDT[,,by=Species][.N]
irisDT[,,by=Species][mult="first"]
irisDT[,,by=Species][mult="first",by=Species]
irisDT[1,,by=Species]
irisDT[.1,,by=Species]
colMeans(irisDF)
colMeans(irisDF[, -c("Species")])
colMeans(irisDF[, -5])
sapply(unique(irisDF$Species), function (x) colMeans(irisDF[irisDF$Species == x, -5]))
dplyr::summarise(group_by(irisDF, Species), colMeans)
library(dplyr)
dplyr::summarise(group_by(irisDF, Species), colMeans)
sapply(unique(irisDF$Species), function (x) colMeans(irisDF[irisDF$Species == x, -5]))
library(dplyr)
dplyr::summarise(group_by(irisDF, Species),
mean(Sepal.Length),
mean(Sepal.Width),
mean(Petal.Length),
mean(Petal.Width))
irisDT[, .(mean(Sepal.Width),
mean(Sepal.Length),
mean(Petal.Width),
mean(Petal.Length)), by = Species]
irisDT[, .(mean(Sepal.Length),
mean(Sepal.Width),
mean(Petal.Length),
mean(Petal.Width)), by = Species]
irisDT[, .(Sepal.Length = mean(Sepal.Length),
Sepal.Width = mean(Sepal.Width),
Petal.Length = mean(Petal.Length),
Petal.Width = mean(Petal.Width)), by = Species]
sapply(unique(irisDF$Species), function (x) colMeans(irisDF[irisDF$Species == x, -5]))
irisDT[,mean,by=species]
irisDT[,mean,by=Species]
irisDT[,mean(),by=Species]
irisDT[,colMeans,by=Species]
irisDT[,colMeans(),by=Species]
colMeans(setosaSubset)
setosaSubset <- irisDF[irisDF$Species == "setosa", ]
colMeans(setosaSubset)
setosaSubset <- irisDF[irisDF$Species == "setosa", -5]
colMeans(setosaSubset)
apply(setosaSubset, 2, sd)
apply(setosaSubset, 2, mean)
apply(setosaSubset, 2, sd)
?split
lapply(split(irisDF, irisDF$Species), colMeans)
lapply(split(irisDF, irisDF$Species),
function (x) colMeans(x[, -5]))
sapply(split(irisDF, irisDF$Species),
function (x) colMeans(x[, -5]))
dplyr::summarise(group_by(irisDF, Species),
mean(Sepal.Length),
mean(Sepal.Width),
mean(Petal.Length),
mean(Petal.Width))
source('~/.active-rstudio-document', echo=TRUE)
save(myGTEx, "GTEx_40Genes.Rdata")
save(myGTEx, file = "GTEx_40Genes.Rdata")
library(ggplot2)
freqTissues <- table(dict[, SMTS])
tissueOrder <- names(freqTissues[order(freqTissues, decreasing = FALSE)])
dict[, SMTS := factor(.SD[,SMTS], levels = tissueOrder, ordered = TRUE)]
ggplot(dict, aes(x = SMTS)) +
geom_bar(fill = "steelblue") +
coord_flip() +
theme_bw()
dim(myGTEx)
heac(colnames(myGTEx))
head(colnames(myGTEx))
tail(colnames(myGTEx))
idxExpressionCols <- which(colnames(myGTEx) %in% colnames(myGTEx)[-c(1:2)])
model <- hclust(dist(myGTEx[, idxExpressionCols][, log2(.SD)]))
myGTEx[, ClusterIDs := cutre(model, k = 8)]
head(myGTEx[, c(1:5, ncol(myGTEx)), with = FALSE])
idxExpressionCols <- which(colnames(myGTEx) %in% colnames(myGTEx)[-c(1:2)])
model <- hclust(dist(myGTEx[, idxExpressionCols][, log2(.SD + 1)]))
myGTEx[, ClusterIDs := cutre(model, k = 8)]
head(myGTEx[, c(1:5, ncol(myGTEx)), with = FALSE])
dim(myGTEx)
idxExpressionCols <- which(colnames(myGTEx) %in% colnames(myGTEx)[-c(1:2)])
model <- hclust(dist(myGTEx[, idxExpressionCols][, log2(.SD + 1)]))
idxExpressionCols <- which(colnames(myGTEx) %in% colnames(myGTEx)[-c(1:2)])
model <- hclust(dist(myGTEx[, idxExpressionCols, with = FALSE][, log2(.SD + 1)]))
myGTEx[, ClusterIDs := cutree(model, k = 8)]
head(myGTEx[, c(1:5, ncol(myGTEx)), with = FALSE])
plot(model)
plot(model, labels = myGTEx[, Description])
?randomForest
library(randomForest)
?randomForest
library(randomForest)
forest <- randomForest(myGTEx[, idxExpressionCols, with = FALSE],
y = myGTEx[, ClusterIDs],
importance = TRUE)
dim(forest$importance)
head(forest$importance, 50)
head(forest$importance, 10)
features <- forest$importance[order(forest$importance[, 2]), 2]
head(forest, 20)
head(feautres, 20)
head(features, 20)
features <- forest$importance[order(forest$importance[, 2],
decreasing = TRUE), 2]
head(features, 20)
head(features, 50)
head(names(features))
names(forest)
forest$mse
names(forest)
table(forest$predicted, myGTEx[, ClusterIDs])
idxExpressionCols <- which(colnames(myGTEx) %in% colnames(myGTEx)[-c(1:2)])
model <- hclust(dist(myGTEx[, idxExpressionCols, with = FALSE][, log2(.SD + 1)]))
plot(model, labels = myGTEx[, Description])
myGTEx[, ClusterIDs := factor(cutree(model, k = 8))]
head(myGTEx[, c(1:5, ncol(myGTEx)), with = FALSE])
library(randomForest)
forest <- randomForest(myGTEx[, idxExpressionCols, with = FALSE],
y = myGTEx[, ClusterIDs],
importance = TRUE)
with(forest, table(predicted, myGTEx[, ClusterIDs]))
?plot.hclust
plot(model, labels = myGTEx[, Description], col.xlab = myGTEx[, Description])
plot(model, labels = myGTEx[, Description], colxlab = myGTEx[, Description])
plot(model, labels = myGTEx[, Description], col.axis = myGTEx[, Description])
plot(model, labels = myGTEx[, Description], col.axis = myGTEx[, Description])
features <- forest$importance[order(forest$importance[, 2],
decreasing = TRUE), 2]
head(features, 50)
with(forest, table(predicted, myGTEx[, ClusterIDs]))
f2 <- randomForest(myGTEx[, which(colnames(.SD) %in% names(features)[1:100]), with = F],
y = myGTEx[, ClusterIDs])
table(f2$predicted, myGTEx[, ClusterIDs])
names(features)[1:100]
f2 <- randomForest(myGTEx[, which(colnames(myGTEx) %in% names(features)[1:100]), with = F],
y = myGTEx[, ClusterIDs])
table(f2$predicted, myGTEx[, ClusterIDs])
f2 <- randomForest(myGTEx[, which(colnames(myGTEx) %in% names(features)[1:10]), with = F],
y = myGTEx[, ClusterIDs])
table(f2$predicted, myGTEx[, ClusterIDs])
